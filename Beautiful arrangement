class Solution(object):
    # Python function to print permutations of a given list
    def permutation(self,lst):
    
    	# If lst is empty then there are no permutations
    	if len(lst) == 0:
    		return []
    
    	# If there is only one element in lst then, only
    	# one permutation is possible
    	if len(lst) == 1:
    		return [lst]
    
    	# Find the permutations for lst if there are
    	# more than 1 characters
    
    	l = [] # empty list that will store current permutation
    
    	# Iterate the input(lst) and calculate the permutation
    	for i in range(len(lst)):
        	m = lst[i]
        
        	# Extract lst[i] or m from the list. remLst is
        	# remaining list
        	remLst = lst[:i] + lst[i+1:]
        
        	# Generating all permutations where m is first
        	# element
        	for p in self.permutation(remLst):
        		l.append([m] + p)
    	return l
    
   
    

    def countArrangement(self, n):
        data=''
        count=0
        flag=0
        for i in range(1,n+1):
            data+=str(i)
        
        perm=self.permutation(list(data))
        for p in perm:
            for i in range(0,len(p)):
                if i%int(p[i])==0 or int(p[i])%i==0:
                    pass
                else:
                    flag=1
                    break
            if flag==0:
                count+=1
            else:
                flag=0
        return count
                    
                
   

obj=Solution()
print(obj.countArrangement(3))


